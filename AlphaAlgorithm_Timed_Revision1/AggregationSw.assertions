
csp Instantiations csp-begin
nametype nat = {0..4}
Movement_alpha = 2
move_BOUND = 2
nametype string = LSeq(Char,2)
Movement_av = 1
Movement_MB = 1
nametype real = {0,1}
nametype int = { -4..4}
Communication_RC = 1
Communication_id = 0
random() = 0
nametype boolean = Bool
nametype ID = {0,1}
floor(x) = x 
Movement_lv = 1   

Plus(e1,e2,T) = if member(e1+e2,T) then e1+e2 else e1
Div(e1,e2,T) = if member(e1/e2,T) then e1/e2 else e1
Neg(e1,T) = if member(-e1,T) then -e1 else e1
Mult(e1,e2,T) = if member(e1*e2,T) then e1*e2 else e1
Modulus(e1,e2,T) = if member(e1%e2,T) then e1%e2 else e1
Minus(e1,e2,T) = if member(e1-e2,T) then e1-e2 else e1
csp-end

import aggregation::*

assertion Communication is not deterministic (a1)
assertion Communication is divergence-free (a2)
assertion Communication is deadlock-free (a3)

assertion Movement is not deterministic (a4)
assertion Movement is divergence-free (a5)
assertion Movement is deadlock-free (a6)

assertion AggregationSoftware is not deterministic (a7)
assertion AggregationSoftware is divergence-free (a8)
assertion AggregationSoftware is deadlock-free (a9)


csp Spec1 csp-begin
Spec1 = let
Responds = (|~|x:ID @ receive.(Communication_id,x) -> Responds) |~| SKIP
Run = broadcast?x:diff(ID,{Communication_id}) -> receive!(x,Communication_id) -> Run |~| SKIP
Main = broadcast.Communication_id -> (Responds|||Run); Main
within
Main
csp-end

csp Impl1 csp-begin
Impl1 = AggregationSoftware_O\diff(Events,{|receive,broadcast|})
csp-end

assertion Impl1 refines Spec1 (b1) [F] untimed

csp Spec2 csp-begin
Spec2 = let
Moves = moveCall -> moveRet -> (Moves |~| SKIP)
Run = |~|x:Position @ obstacle.x -> Moves; Run
within
Moves; Run
csp-end 

csp Impl2 csp-begin
Impl2 = AggregationSoftware_O\diff(Events,{|moveCall,moveRet,obstacle|})
csp-end

assertion Impl2 refines Spec2 (b2) [F] untimed

csp timed TimedSpec1 csp-begin
Timed(OneStep) {
TimedSpec1 = let
	Responds = (|~|x:ID @ EDeadline(receive.(Communication_id,x),0) ; Responds) |~| SKIP
	Run = broadcast?x:diff(ID,{Communication_id}) -> receive!(x,Communication_id) -> Run |~| SKIP
	Main = broadcast.Communication_id -> (Responds|||Run); Main
within
	Main
}
csp-end

csp timed TimedImpl1 csp-begin
Timed(OneStep) {
	TimedImpl1 = timed_priority(timed::AggregationSoftware|\{|receive,broadcast|})
}
csp-end

csp timed TimedSpec2 csp-begin
TimedSpec2 = let
	Moves = EDeadline(moveCall,0) ; EDeadline(moveRet,0) ; (Moves |~| SKIP)
	Run = |~|x:Position @ obstacle.x -> Moves; Run
within
	Moves; Run
csp-end

csp timed TimedImpl2 csp-begin
Timed(OneStep) {
	TimedImpl2 = timed_priority(timed::AggregationSoftware|\{|moveCall,moveRet,obstacle|})
}
csp-end

assertion TimedImpl1 refines TimedSpec1 (Timed_B1) [F] timed
assertion TimedImpl2 refines TimedSpec2 (Timed_B2) [F] timed

csp timed AuxiliaryDefinitions csp-begin

-- Auxiliary definitions
-- This should allow any other events (including tock) up to 'd' time units to elapse, and
-- when an event in {e} happens it does SKIP.
ADeadline(e,d) = if card(e) == 0 then
					((CHAOS(diff(Events,{finished})) [| {tock} |] (Countdown(d) ; finished -> SKIP)) [|{finished}|> SKIP)\{finished}
				 else
				 	(CHAOS(Events) [| {tock} |] Countdown(d)) [|e|> SKIP

-- Offers any event non-deterministically, and if 'e' is chosen, then it terminates.
AnyOther(e) = CHAOS(Events) [|e|> SKIP

Timed(OneStep) {
CommunicationStateSpent(t,x) = 
		let
			Main = AnyOther({|Communication_enterV.x|}) ; ADeadline({|Communication_exitV.x|},t) ; Main
		within
			timed_priority(Main)
			
}

Timed(OneStep) {
EnterExactly(t) = 
	let
		Initial = ADeadline({|Communication_enterV."Communication_Receive"|},0)
		EveryT = ADeadline({|Communication_enterV."Communication_Receive"|},t) ; EveryT
	within
		timed_priority(Initial ; EveryT)
}

csp-end

csp timed T_AggregationSoftware_Communication_VS csp-begin
T_AggregationSoftware_Communication_VS = ShowV_Communication(timed::AggregationSoftware_VS)
csp-end

csp timed TB1 csp-begin
TB1 = CommunicationStateSpent(Communication_RC,"Communication_Receive")
csp-end

csp timed TB2 csp-begin
TB2 = EnterExactly(Communication_RC)
csp-end

csp timed TB3 csp-begin
TB3 = CommunicationStateSpent(0,"Communication_Broadcast")
csp-end

csp timed TB4 csp-begin
NoEvent = AnyOther({|broadcast.Communication_id|}) ; BroadcastHappened(0)

BroadcastHappened(t) = (t < Communication_RC & (broadcast ?x-> SomeHappened(t) 
											   [] 
											   receive?x:{x|x <- {(Communication_id,x0) | x0 <- ID}} -> SomeHappened(t) 
											   [] 
											   tock -> BroadcastHappened(t+1)))
						[]
						t == Communication_RC & NoEvent

SomeHappened(t) = t < Communication_RC & (AnyOther({tock}) ; SomeHappened(t+1))
				  []
				  t == Communication_RC & NoEvent

TB4 = CHAOS({|moveCall,moveRet,obstacle,tock|}) [| {tock} |] NoEvent
csp-end

csp timed TB5 csp-begin
Timed(OneStep) {
-- Requirement TB.5
EveryMBEnterTurning =
	let
		Main = ADeadline({|aggregation_Movement_enterV."aggregation_Movement_Turning"|},Movement_MB) ; Main
	within
		timed_priority(Main)
}

TB5 = EveryMBEnterTurning
csp-end

csp timed T_AggregationSoftware_Movement_VS csp-begin
T_AggregationSoftware_Movement_VS = ShowV_aggregation_Movement(timed::AggregationSoftware_VS)
csp-end

csp timed TB6 csp-begin
Timed(OneStep) {
MovementStateSpent(t,x) =
	let
		Main = AnyOther({|aggregation_Movement_enterV.x|}) ; ADeadline({|aggregation_Movement_exitV.x|},t) ; Main
	within
		timed_priority(Main)
}
TB6 = MovementStateSpent(Movement_MB,"aggregation_Movement_MovementAndAvoidance")
csp-end

csp timed TB7 csp-begin
TB7 = MovementStateSpent(360/Movement_av,"aggregation_Movement_MovementAndAvoidance_Avoid")
csp-end

csp timed TB8 csp-begin
TB8 = MovementStateSpent(360/Movement_av,"aggregation_Movement_Turning")
csp-end

assertion T_AggregationSoftware_Communication_VS refines TB1 (Timed_TB1) [FD] timed
assertion T_AggregationSoftware_Communication_VS refines TB2 (Timed_TB2) [FD] timed
assertion T_AggregationSoftware_Communication_VS refines TB3 (Timed_TB3) [FD] timed
assertion AggregationSoftware refines TB4 (Timed_TB4) [FD] timed
assertion T_AggregationSoftware_Movement_VS refines TB5 (Timed_TB5) [FD] timed
assertion T_AggregationSoftware_Movement_VS refines TB6 (Timed_TB6) [FD] timed
assertion T_AggregationSoftware_Movement_VS refines TB7 (Timed_TB7) [FD] timed
assertion T_AggregationSoftware_Movement_VS refines TB8 (Timed_TB8) [FD] timed

